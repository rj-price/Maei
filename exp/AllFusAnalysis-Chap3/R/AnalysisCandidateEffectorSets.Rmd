---
title: "Analysis of Candidate Effectors"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Data set

Candidate effectors were generated as part of the Third Chapter of my thesis. They were identified using the [Maei pipeline](https://github.com/JamiePike/Maei) in a set of *Fusarium* genomes. For the full set of genomes and the previous command line scripts and analysis, see [Process.md](https://github.com/JamiePike/Maei/docs/Process.md). 

```{r libraries, echo=FALSE, include=FALSE}
# # ---- Install required packages ---- #
# install.packages("ggtree")
# if (!requireNamespace("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
# BiocManager::install("ggtree")
# install.packages('devtools')
# devtools::install_github("YuLab-SMU/ggtreeExtra")
# install.packages('tidytree')
# install.packages('ggpubr')
# install.packages('nortest')

# ---- Load required libraries ---- #
#for stats
library(dplyr)
library(tidyr)
library(tidytree)
library(tidyverse)
library(dplyr)
library(forcats)
library(ggplot2)
library(ggthemes)
library(viridis)
library(ggpubr)
library(nortest)

# for phylogeny
library(phytools)
library(ggtree)
library(ggtreeExtra)
library(ape)

#for heatmaps
library(textshape)
library(RColorBrewer)
library(ggnewscale)
library(pheatmap)
```


```{r load data}

# ---- Set dirs and load files ---- #
setwd("/Volumes/Jamie_EXT/Projects/Maei/exp/AllFusAnalysis-Chap3/R/")
# Specify  path to  Newick file
tree_file <- "./MaeiTEFPhylo.treefile"
# Load heatmap data matrix from the CSV file
data <- read.csv("./PhyloHeatmapData.csv")  # Adjust the path accordingly
# Load phylogeny meta date from the CSV file
metadata <- read.csv("./PhyloMetaData.csv") 

```

After loading my data, I prepared it for subsequent analysis. The metadata and heatmap data are currently in .csv format, but that saves empty cells as "", and I want them to be `NA` values (particularly the metadata). I also added columns which contains the "full name" for each genome assembly, where full name is the genus (abbreviated), species, and forma speciales (fsp). 

```{r prepare metadata}
# ---- prepare metadata ---- #
# ensure its a df
metadata <- as.data.frame(metadata)
# clear empty values
metadata$fsp[metadata$fsp==""] <- NA # set empty cells in fsp column to NA
metadata$race[metadata$race==""] <- NA # set empty cells in race column to NA

#create a column for full fsp.
metadata <- metadata %>% unite("full_name", c(species,fsp), sep = " fsp. ", remove = F, na.rm = T)

# build df for fsp so we can add it as a colour scale to the tree
fsp_df <- data.frame("fsp" = metadata[,c("fsp")] )
rownames(fsp_df) <- metadata$label

```

## Tef-1a tree of isolates

Now I have my database of isolates, I need to know how they are related. I have already performed the phylogenetic analysis, here I am plotting the results. First, I rooted the tree through F._graminearum_PH-1 *Tef1-a*, and built the basic tree skeleton. I also loaded in the metadata for labeling later. Additionally, I built a basic tree with the nodes labeled, so that I can use that for later reference 

```{r prep tree, fig.width= 20}
# ---- Prepare the tree ---- #
# Read the phylogenetic tree from the Newick file
unrootedtree <- read.tree(tree_file)
# root the tree
tree <- root(unrootedtree, outgroup = c("F._graminearum_PH-1"))
# Build tree skeleton
p <- ggtree(tree,ladderize = F)  %<+% metadata

# ---- View the tree ---- #
# Useful for visualusing nodes etc 
p_nodes <- p + 
  geom_text2(aes(label = parent), hjust = -0.1, size = 3)+ # add node names
  geom_tiplab(aes(label = label), offset = 0.005) +
  coord_cartesian(clip = "off") # stop names being trimmed off
```

Now I have my basic tree, I can start to build something that will stand alone. First I added the metadata (full name, the isolate code, and race).

```{r TEF1a tree, results= 'hide'}
# ---- Build the tree plot ---- #

p2 <- p +  
  geom_treescale(x = 0, y = 1, width = 0.004) + 
  geom_tiplab(aes(label = full_name)) +
  geom_tiplab(aes(label = isolate_code), color = "black", offset = 0.015, linetype = "blank", geom = "text", align = TRUE) +
  geom_tiplab(aes(label = race), color = "black", offset = 0.024, linetype = "blank", geom = "text", align = TRUE)+
  geom_tippoint(aes(shape = source)) +
  geom_rootedge() +
  theme(legend.position = "bottom")

#add extra scale so we can plot fsp with colour
p3 <- p2 + new_scale_fill()
# add race data
p4 <- gheatmap(p3, fsp_df,
               offset = 0.008, 
               width = 0.03,
               color = "black",
               colnames = FALSE) +
  scale_fill_manual(name = "Fsp",
                    values = c("blue","purple","goldenrod4","grey90","gold","brown", "lightpink","darkolivegreen3", "black", "tomato", "lavender", "tan", "palegreen4", "coral", "yellow"), na.value = "grey") +
  theme(legend.position = "bottom",
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 12),
        legend.box = "vertical", legend.margin = margin())+
  guides(shape = guide_legend(override.aes = list(size = 2)))
```

The TR4 isolates group into a monophyletic clade, as expected; as do the *lactucae* isolates. The TNAU isolates group as they did in the previous TEF1a and RBP2 phylogenies (chapter 2). Isolates of the same fsp and race do not all group in the same clade (e.g. *Fo.* fsp. *cubense* Race 1)

```{r TEF1a tree plot, fig.height= 10, fig.width= 30, fig.cap="TEF phylogeny of Fusarium isolates included int effector anaylisis.The tree is rooted through F. graminearum."}
# plot it 
plot(p4)

##save basic tree 
ggsave("BasicTEFPhylo.png", width = 30, height = 15)
```

## Analysis of candidate effectors, *mimps* and genome size in data set

Once the candidate effectors had been identified in the candidates, I conducted some basic statistics to see how they were distributed.

First, I subset the data I needed from the `Metadata`, and removed the isolates that were included in the TEF1a phylogenies but not the Maei analysis. 

```{r stats data set}
# ----  tidy the data for stats ----#
#subset the df so that we can perform stats on genome size and mimp/cand eff distribution
stats_data <- select(metadata, "species", "fsp", "isolate_code","no._mimps","no._cand_effs","genome_size") %>%
#Rename the columns to reduce the long titles
  rename(isolate=isolate_code,
         mimps=no._mimps,
         candidate_effectors=no._cand_effs,
         assembly_size =genome_size)

#we need to drop rows which were not included in the Maei analysis
stats_data <- stats_data %>%
  drop_na(candidate_effectors)

# view the table for stats data
knitr::kable(stats_data)
```

The number of *mimps*,  candidate effectors identified, and genome sizes varies between genome assemblies. 

```{r stats_data}
# ---- sumarise the data ---- #
summary(stats_data$mimps)
summary(stats_data$candidate_effectors)
summary(stats_data$assembly_size)
```


### Correlation and distribution

I want to see if there is a relationship between the assembly size, *mimp* content, and candidate effector number, so calculated correlation. 

First, I checked the distribution of the data, to determine the best correlation test to perform. 

```{r distribution plots}
# ---- Build the histograms ---- #
# visualise the mimp distribution
mimps_histo <- ggplot(stats_data, aes(x = mimps)) +
  geom_histogram(fill = "#0c4c8a", colour = "black" ) +
  theme_bw()

# visualise the mimp distribution
cands_histo <- ggplot(stats_data, aes(x = candidate_effectors)) +
  geom_histogram(fill = "#0c4c8a", colour = "black" ) +
  theme_bw()

# visualise the mimp distribution
size_histo <- ggplot(stats_data, aes(x = assembly_size)) +
  geom_histogram(fill = "#0c4c8a", colour = "black" ) +
  theme_bw()

```

The data are not normality distributed. The Pearson correlation is computed by default with the `cor.test()` function.

I also visualized the data using scatter plots to check that the data are linearly related. 

```{r correlation plots}

# ---- Build the scatter plots ---- #
#Correlation between the total number of effectors and  the total number of mimps
#Visualize the relationship
effectors_v_mimps_relat <- ggplot(stats_data) +
  aes(x = candidate_effectors, y = mimps) +
  geom_point(colour = "#0c4c8a") +
  geom_smooth(method = "lm", se = FALSE, color = "black") +
  theme_bw()

#Correlation between  the total number of effectors and Assembly Size?
#Visualize the relationship
effectors_v_assembly_size_relat <- ggplot(stats_data) +
  aes(x = candidate_effectors, y = assembly_size) +
  geom_point(colour = "#0c4c8a") +
  geom_smooth(method = "lm", se = FALSE, color = "black") +
  theme_bw()

#Correlation between the total number of mimps and Assembly Size?
#Visualize the relationship
mimps_v_assembly_size_relat <- ggplot(stats_data) +
  aes(x = mimps, y = assembly_size) +
  geom_point(colour = "#0c4c8a") +
  geom_smooth(method = "lm", se = FALSE, color = "black") +
  theme_bw()

```


```{r stats plots, fig.height= 15, fig.width= 35, fig.cap= "Plots of meta data, showing distribution and relationship of assembly size, mimp, and candidate effector content"}

# combine the plots 
sats_plots <- ggarrange(mimps_histo, cands_histo, size_histo, mimps_v_assembly_size_relat, effectors_v_assembly_size_relat, effectors_v_mimps_relat,
          ncol = 3, 
          nrow = 2)

# plot the combined plots
plot(sats_plots)


#save it 
ggsave("./SummaryStats.png", width = 20, height = 15)

```

There is a general positive trend in the data between candidate effector number and total number of mimps identified. 

Note: the correlation between variables X and Y is equal to the correlation between variables Y and X so the order of the variables in the `cor.test()` function does not matter. 


```{r candidate effectors and mimps correlation"}
#Correlation test:
effectors_v_mimps <- cor.test(stats_data$candidate_effectors, stats_data$mimps, )
effectors_v_mimps
```
For the correlation between "candidate_effectors" and "mimps," the Pearson's correlation coefficient is 0.88. This indicates a strong positive correlation between these two variables. The p-value (1.674e-14) is very small, suggesting that this correlation is statistically significant. The 95 percent confidence interval for the correlation coefficient ranges from 0.786 to 0.934. Overall, it implies a robust and positive association between "candidate_effectors" and "mimps" in my data.

```{r candidate effectors and assembly size}

#Correlation test:
effectors_v_assembly_size <- cor.test(stats_data$candidate_effectors, stats_data$assembly_size) 
effectors_v_assembly_size
```
Similarly, for the correlation between "candidate_effectors" and "assembly_size," the Pearson's correlation coefficient is 0.91. This indicates a very strong positive correlation between these two variables. The p-value is extremely small (< 2.2e-16), indicating that this correlation is highly statistically significant. The 95 percent confidence interval for the correlation coefficient ranges from 0.837 to 0.951. Overall, it suggests a strong and positive association between "candidate_effectors" and "assembly_size" in my dataset.

```{r mimps and assembly Size}

#Correlation test:
mimps_v_assembly_size <- cor.test(stats_data$mimps, stats_data$assembly_size)
mimps_v_assembly_size
```

The Pearson's correlation coefficient between "mimps" and "assembly_size" variables is 0.87. This indicates a strong positive correlation between the two variables. The p-value is very small (7.091e-14), suggesting that this correlation is statistically significant. The 95 percent confidence interval for the correlation coefficient ranges from 0.770 to 0.929. Overall, it implies a robust and positive association between the variables in my data.

### Relationship between predicted effectors, *Mimps* and Assembly size

Although I have ploted and calculated correlation between the number of *mimps*, candidate, effectors and assembly size, it is not easy to visualise/see in one place. Therefore, I generated a single plot which contains the number of *mimps*, candidate effectors, and assembly size for each isolate. This makes it quick and easy to visualise, and see if there is a relationship between the variables. 

First, I have to prepare my data set. I used the metadata file loaded initially. 
```{r stats final plot data }
# ---- Prepare Data for plotting --- #
#Extract the isolate, assembly size, total number of mimps and effectors columns.
stats_plot_data <- select(metadata,"species", "species_group", "fsp", "isolate_code","genome_size","no._mimps","no._cand_effs") %>%
#Rename the columns to reduce the long titles
  rename(isolate=isolate_code,                                    
         mimps=no._mimps,
         candidate_effectors=no._cand_effs,
         assembly_size =genome_size) %>%  
#We need to drop rows which were not included in the Maei analysis
  drop_na(candidate_effectors) %>%
#Merge/group the fsp and isolate code columns so that both can be plotted.
   unite(ID, c(fsp, isolate), sep = " ", remove = T, na.rm = T) %>%
#Merge/group the mimps and effector columns so that both can be plotted per strain/isolate.
  pivot_longer(cols = c(mimps,candidate_effectors), names_to="Legend", values_to="mimps_and_candidate_effectors") %>%  
  mutate(Legend = factor(Legend, levels=c('mimps','candidate_effectors')))

```

Once the data was prepared, I produced a plot using ggplot2. 

```{r stats final plot, fig.width= 15, fig.height= 10, fig.cap="Figure 4:Relationship between candidate effectors, *mimps* and assembly size."}
#Build plot
#----------

#Generate scale for Assembly size data 
scale_right <- 100 / max(stats_plot_data$mimps_and_candidate_effectors)

#Build Plot
stats_plot <- ggplot(aes(x=reorder(ID, mimps_and_candidate_effectors)),   #Create X axis, which contains all strains/isolates assessed ordered by the total number of mimps and effectors 
               data = stats_plot_data)+  
  geom_bar(aes(y=mimps_and_candidate_effectors,                  #Plot the total number of mimps and effectors 
               fill = Legend),
           colour="black",
           position= 'dodge',                          #Ensure the bars are not stacked. 
           stat='identity')+                           #Add the mimp or predicted effector content. 
  scale_fill_manual("Legend", values=c("candidate_effectors" = "darkolivegreen", "mimps" = "#DDE0DA"), label=c("mimps", "candidate effectors"))+ #for some reason the labels have to be written the other way round...?
  facet_grid(~species_group,
             scales = "free_x",                        # Let the x axis vary across facets.
             space = "free_x",                         # Let the width of facets vary and force all bars to have the same width.
             switch = "x")+                            # Move the facet labels to the bottom.
  geom_point(aes(y=assembly_size /scale_right,         #Plot assemble size over the top of the bar chart.
                 colour = "Assembly Size",             #Add assembly size to the legend. 
                 group = 1))+ 
  scale_colour_manual(" ", values=c("Assembly Size" = "black"))+
  theme_bw()+
  theme(legend.box="verticle",
        legend.title = element_blank())+
  xlab("") +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank())+
  theme(axis.text.x = element_text(angle = 90,         #Adjust the text orientation on the x axis
                                   vjust = 0.5, 
                                   hjust=1,
                                   size = 8))+
  theme(axis.text = element_text(size = 8))+
  scale_y_continuous(name= "Total number of mimps \nand candidate effectors", #Increase ticks on Y axis.
                     breaks = scales::pretty_breaks(n = 10),                     #Create regular breaks in the Y axis. 
                     sec.axis = sec_axis( trans=~.*scale_right,                   #Insert second Y axis for the assembly size. Calculated using the right-hand scale.   
                                          name="Size of Assembly (Mb)", 
                                          breaks = scales::pretty_breaks(n = 15)
                     ))
# print the plot
plot(stats_plot)
#Prepare png of file 
ggsave("StatsOverview.png", width = 15, height = 10)

```
### Additional statsistics 

I considered performing t-tests to see if there was a significant difference in the number of *mimps* and candidate effectors identified between race in each fsp, but as the number of fsp for *Fo.* fsp. *cubense* was not even, and one of the three Race 1 isolates reported might not be pathogenic (Foc1 60), I decided not to test for significance - even using non-parametric tests. The sample number is too low. 

I wondered if there was a reduced number of effectors in the Foc isolates compared to the other fsp. They do consistently seem to have fewer identified. Further, I wondered if there was a difference in the number of *mimps* and candidate effectors between different races of the same fsp, even if it was not signifcant. 

I plotted the mimp and effector content from the metadata and visualised it using `ggplot.`

```{r effector and mimp race plots, fig.width= 12}

# ---- Prepare Data for plotting --- #
#Extract the isolate, assembly size, total number of mimps and effectors coloumns.
race_plot_data <- select(metadata,"species", "species_group", "fsp", "race" ,"isolate_code","genome_size","no._mimps","no._cand_effs") %>%
#Rename the columns to reduce the long titles
  rename(isolate=isolate_code,                                    
         mimps=no._mimps,
         candidate_effectors=no._cand_effs,
         assembly_size =genome_size) %>%  
#We need to drop rows which were not included in the Maei analysis
  drop_na(candidate_effectors) %>%
#Merge/group the mimps and effector columns so that both can be plotted per strain/isolate.
  pivot_longer(cols = c(mimps,candidate_effectors), names_to="Legend", values_to="mimps_and_candidate_effectors") %>%  
  mutate(Legend = factor(Legend, levels=c('mimps','candidate_effectors')))


# ---- subset metadata ---- #
# extract only the fsp we are interested in 
race_plot_data_subset <- subset(race_plot_data, grepl("lactucae|apii|cubense", fsp)) %>% 
  drop_na(race)


# ---- funky cheats to lable the facet plot nicely --- #

#set new labels
new_labels_y <- c("mimps" = "mimps", "candidate_effectors" = "candidate effectors")
new_labels_x <- c("apii" = "Fo. fsp. apii", "cubense" = "Fo. fsp. cubense", "lactucae" = "Fo. fsp. lactucae")


# ---- build plots ---- #
theme_set(theme_pubr()) #set the ggpubr theme

# build plots for candidate effectors and mimps 
mimpsandcandeffs <- ggplot(race_plot_data_subset, aes(x=race, y=mimps_and_candidate_effectors)) + # plot race and mimp/candidate effector count
  geom_boxplot(aes(fill = Legend)) +
  facet_wrap(~ fsp, labeller = labeller(Legend = new_labels_y, fsp = new_labels_x), scales = "free_x") +  # split the plot by fsp and then mimps/candidate effectors
  labs(x = "Race", 
       y = "Count") +
  scale_fill_manual(values = c("candidate_effectors" = "darkolivegreen", "mimps" = "#DDE0DA"), label=c("mimps", "candidate effectors")) +
  theme(strip.text.y = element_blank(),  # remove the side names as we have this shown in colour now. 
        panel.grid.major = element_line(), #Â put the lines back in 
        legend.position = "bottom", 
        legend.title = element_blank())
#plot it 
plot(mimpsandcandeffs)

#save the plot
ggsave("MimpsAndCandEffs_CubenseOnly.png", width = 20, height = 10)


```

## Candidate effector distribution

Now I have an understanding of the effector distribution and the phylogeny, I combined the phylogenies and effector profiles to generate a heat map. For this, I can use the tree (p4) already generated and add the heatmap data I loaded initially (data).

First, I need to prepare the heatmap data. As we are looking at clustered (0.65% ID, cd-hit (v...)) and filtered sequences (SignalP (v5.06) and EffectorP (v2.0.1) extracted from BLAST hits, the total number of candidate effectors per cluster per isolate varies, but I want to just look at Presence/\nAbsence. In order to do this, I converted the heatmap data matrix to a binary data frame. 

```{r heatmap data prep}
# ---- Prep the heatmap data ---- #
# remove the row names temporarily 
rownames_mat<- data[,1]
mat_data<- as.matrix(data[,-1])
#make data frame binary 
binary_matrix <- as.matrix(mat_data)
binary_matrix[binary_matrix > 0] <- 1
#put rownames back
rownames(binary_matrix)<-rownames_mat
```

Next, I clustered the data in the binary data matrix, so that it will be ordered  when I visualise the candidate effector heatmap.

```{r dendrogram of effector clusters, fig.height= 5, fig.width= 20}
# ---- Cluster the heatmap data ---- #
# normalisiation is mandatory for clustering, but as my data is binary - i did not normalise. 
# Compute hierarchical clustering of columns
heatmap_dat <- cluster_matrix(binary_matrix, dim = 'col', method ="ward.D2")

```

Next, in theory, I add the heatmap to the tree already built... but I cant get the offsets to align consistently and it overlaps if i just add heatmap_dat to p4, so I have to rebuild p4.

```{r final heatmap, fig.height= 10, fig.width= 30}
# ---- Build the full figure ---- #
p2 <- p +  
  geom_treescale(x = 0, y = 1, width = 0.004) + 
  geom_tiplab(aes(label = full_name), offset = 0.001) +
  geom_tiplab(aes(label = isolate_code), color = "black", offset = 0.028, linetype = "blank", geom = "text", align = TRUE) +
  geom_tiplab(aes(label = race), color = "black", offset = 0.047, linetype = "blank", geom = "text", align = TRUE)+
  geom_tippoint(aes(shape = source), size = 3) +
  geom_rootedge() +
  theme(legend.position = "bottom")

#add extra scale so we can plot fsp with colour
p3 <- p2 + new_scale_fill()
# add race data
p4 <- gheatmap(p3, fsp_df,
               offset = 0.02, 
               width = 0.03,
               color = "black",
               colnames = FALSE) +
  scale_fill_manual(name = "Fsp",
                    values = c("blue","purple","goldenrod4","grey90","gold","brown", "lightpink","darkolivegreen3", "black", "tomato", "lavender", "tan", "palegreen4", "coral", "yellow"), na.value = "grey") +
  theme(legend.position = "bottom",
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 12),
        legend.box = "vertical", legend.margin = margin())+
  guides(shape = guide_legend(override.aes = list(size = 2)))

# add extra discrete scale
p5 <- p4 + new_scale_fill()

# add effector heatmap
p6 <-gheatmap(p5, heatmap_dat, offset=0.07, colnames=FALSE, legend_title="Presence/\nAbsence", color = NULL,  width = 1.5)  +
  scale_fill_continuous(name = "Presence/\nAbsence",
                        low = "white", high = "darkolivegreen",
                        breaks = c("Absent","Present"),
                        na.value = "grey")+
  guides(fill = guide_colourbar(barwidth = 5, barheight = 1))+
  theme(legend.position = "bottom",
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 12),
        legend.box = "horizontal", legend.margin = margin())+
  guides(shape = guide_legend(override.aes = list(size = 2)))

plot(p6)

# save the output
ggsave("HeatmapAndPhylo.png", width = 30, height = 10)

```

### Candidate effector distribution in Fo. fsp. cubense

Now I have my overall heatmap, I want to look at some of the fsp in more detail - particularly those for which we have multiple races available. I subset my metadata, searched for all caseses that did not match the regex "Fo._fsp._cubense" and dropped them from the tree using the `drop.tip` function. I the reconstructed my tree using just the Foc tef phylo and foc effector profiles. 

```{r cubense effector distib, fig.height= 10, fig.width= 20}

# ---- subset foc metadata ---- #
#identify all rows in the metadata which do not contain cubense 
foc_set_df <- subset(metadata, !grepl("Fo._fsp._cubense|Fo._Fo47", label))
#subset just tip labels
foc_set <- data.frame("label" = foc_set_df[,c("label")])
# convert it to a list 
foc_set_2 <- paste(foc_set$label, sep = ",")

# ---- subset foc heatmap data ---- #
# reduce the white space in the heatmap but filtering columns where there is no data for foc
# first we extract only the foc rows using the same approach as for the metadata, but instead we perform on the binary matrix
foc_heat_df <- subset(binary_matrix, grepl("Fo._fsp._cubense|Fo._Fo47", rownames(binary_matrix)))
# now we need to drop the empty columns 
foc_heat_df <- foc_heat_df[, colSums(foc_heat_df != 0) > 0]

# ---- Cluster the heatmap data (again)---- #
# normalisiation is mandatory for clustering, but as my data is binary - i did not normalise. 
# Compute hierarchical clustering of columns
foc_heat_df <- cluster_matrix(foc_heat_df, dim = 'col', method ="ward.D2")

# ---- build the basic foc tree ---- #
#dop the non foc tip from the tree
tree_reduced <- drop.tip(tree, foc_set_2)
#build a tree from this data and add in out metadata
foc_tree <- ggtree(tree_reduced, ladderize = T ) %<+% metadata 

# ---- build full foc specific tree ---- #
# now make the tree pretty 
foc_tree_2 <- foc_tree +  
  #geom_tiplab(aes(label = full_name), offset = 0.00001) +
  geom_tiplab(aes(label = isolate_code), color = "black", offset = 0.0003, linetype = "blank", geom = "text", align = TRUE) +
  geom_tiplab(aes(label = race), offset = 0.0038, linetype = "blank", geom = "text", align = TRUE)+
  geom_tippoint(aes(shape = source), size = 3) +
  geom_rootedge() +
  theme(legend.position = "bottom")

#add extra scale so we can plot fsp with colour
foc_tree_3 <- foc_tree_2 + new_scale_fill()
# add race data
foc_tree_4 <- gheatmap(foc_tree_3, foc_heat_df, offset=0.008, colnames=T, colnames_angle=90, hjust=1, font.size=3, legend_title="Presence/\nAbsence", color = "grey",  width = 4)  +
  scale_fill_continuous(name = "Presence/\nAbsence",
                        low = "white", high = "darkolivegreen",
                        breaks = c("Absent","Present"),
                        na.value = "grey")+
  guides(fill = guide_colourbar(barwidth = 5, barheight = 1))+
  theme(legend.position = "bottom",
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 12),
        legend.box = "horizontal", legend.margin = margin())+
   geom_treescale(x=0, y=0.1, width = 0.004) +
  guides(shape = guide_legend(override.aes = list(size = 2))) +
    theme(axis.text.x = element_text(angle = 90,         #Adjust the text orientation on the x axis
                                   vjust = 0.5, 
                                   hjust=1,
                                   size = 8,
                                   colour = "white" )) +
  coord_cartesian(clip = "off")

# plot the tree
plot(foc_tree_4)

# save the tree
ggsave("HeatmapAndPhylo_CubenseOnly.png", width = 20, height = 10)

```

We can see that the effector profiles differ based on race and overall tef1 phylogeny. Interestingly there is one candidate which is shared across the R1 and suspected STR4 isolates but not found in the TR4 isolates - cognate R gene? 

I think it is interesting, though we cannot do any really significant stats on this, to look at candidate effector and mimp content among the race groups. 

I was expecting to see a fairly similar number of mimps and candidate effectors among the TR4 isolates, as they are from a monophyletic clade in tef and rbp2 phylos, but number of candidates varies. I am thinking it may be due to assembly quality too? Looking at the Foa isolates is a good way to do this, as the R4 and R2 assemblies are from the same isolates but diff versions prepared by diff people using different methods. 

### Candidate effector distribution in Fo. fsp. lactucae and Fo. fsp. apii

```{r coriandrii and apii effector distib, fig.height= 10, fig.width= 20}

# ---- subset metadata ---- #
#identify all rows in the metadata which do not contain apii and coriandrii 
foa_c_set_df <- subset(metadata, !grepl("Fo._fsp._coriandrii|Fo._fsp._apii|Fo._Fo47", label))
#subset just tip labels
foa_c_set <- data.frame("label" = foa_c_set_df[,c("label")])
# convert it to a list 
foa_c_set_2 <- paste(foa_c_set$label, sep = ",")

# ---- subset heatmap data ---- #
# reduce the white space in the heatmap but filtering columns where there is no data for foc
# first we extract only the foc rows using the same approach as for the metadata, but instead we perform on the binary matrix
foa_c_heat_df <- subset(binary_matrix, grepl("Fo._fsp._coriandrii|Fo._fsp._apii|Fo._Fo47", rownames(binary_matrix)))
# now we need to drop the empty columns 
foa_c_heat_df <- foa_c_heat_df[, colSums(foa_c_heat_df != 0) > 0]

# ---- Cluster the heatmap data (again)---- #
# normalisiation is mandatory for clustering, but as my data is binary - i did not normalise. 
# Compute hierarchical clustering of columns
foa_c_heat_df <- cluster_matrix(foa_c_heat_df, dim = 'col', method ="ward.D2")

# ---- build the basic foc tree ---- #
#dop the non foc tip from the tree
tree_reduced <- drop.tip(tree, foa_c_set_2)
#build a tree from this data and add in out metadata
foa_c_tree <- ggtree(tree_reduced, ladderize = T ) %<+% metadata 

# ---- build full foc specific tree ---- #
# now make the tree pretty 
foa_c_tree_2 <- foa_c_tree +  
  #geom_tiplab(aes(label = full_name), offset = 0.00001) +
  geom_tiplab(aes(label = fsp), color = "black", offset = 0.0003, linetype = "blank", geom = "text", align = TRUE) +
  geom_tiplab(aes(label = isolate_code), color = "black", offset = 0.002, linetype = "blank", geom = "text", align = TRUE) +
  geom_tiplab(aes(label = race), offset = 0.0042, linetype = "blank", geom = "text", align = TRUE)+
  geom_tippoint(aes(shape = source), size = 3) +
  geom_rootedge() +
  theme(legend.position = "bottom")

#add extra scale so we can plot fsp with colour
foa_c_tree_3 <- foa_c_tree_2 + new_scale_fill()
# add race data
foa_c_tree_4 <- gheatmap(foa_c_tree_3, foa_c_heat_df, offset=0.0065, colnames=T, colnames_angle=90, hjust=1, font.size=3, legend_title="Presence/\nAbsence", color = "grey",  width = 4)  +
  scale_fill_continuous(name = "Presence/\nAbsence",
                        low = "white", high = "darkolivegreen",
                        breaks = c("Absent","Present"),
                        na.value = "grey")+
  guides(fill = guide_colourbar(barwidth = 5, barheight = 1))+
  theme(legend.position = "bottom",
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 12),
        legend.box = "horizontal", legend.margin = margin())+
   geom_treescale(x=0, y=.1, width = 0.004) +
  guides(shape = guide_legend(override.aes = list(size = 2))) +
    theme(axis.text.x = element_text(angle = 90,         #Adjust the text orientation on the x axis
                                   vjust = 0.5, 
                                   hjust=1,
                                   size = 8,
                                   colour = "white" )) +
  coord_cartesian(clip = "off") 
# plot the tree
plot(foa_c_tree_4)

# save the tree
ggsave("HeatmapAndPhylo_ApiiAndCoriandriiOnly.png", width = 20, height = 10)

```


As I compared effector content between races for Foc, I also want to do the same thing for Fola. Again, I would have liked to performed some statistical analysis, but pretty much all blogs, posts, and papers I have come across have recommended not doing it with a such a small sample size. I have therefore just plotted the effector data for the Fola isolates. I also included matthiolae, as it appears to be in the same clade based on TEF, but displays a different candidate effector profiles.

```{r lactucae effector distib, fig.height= 10, fig.width= 20}

# ---- subset fola metadata ---- #
#identify all rows in the metadata which do not contain lactucae 
fola_set_df <- subset(metadata, !grepl("Fo._fsp._lactucae|Fo._fsp._matthiolae|Fo._Fo47", label))
#subset just tip labels
fola_set <- data.frame("label" = fola_set_df[,c("label")])
# convert it to a list 
fola_set_2 <- paste(fola_set$label, sep = ",")

# ---- subset fola heatmap data ---- #
# reduce the white space in the heatmap but filtering columns where there is no data for foc
# first we extract only the foc rows using the same approach as for the metadata, but instead we perform on the binary matrix
fola_heat_df <- subset(binary_matrix, grepl("Fo._fsp._lactucae|Fo._fsp._matthiolae|Fo._Fo47", rownames(binary_matrix)))
# now we need to drop the empty columns 
fola_heat_df <- fola_heat_df[, colSums(fola_heat_df != 0) > 0]

# ---- Cluster the heatmap data (again)---- #
# normalisiation is mandatory for clustering, but as my data is binary - i did not normalise. 
# Compute hierarchical clustering of columns
fola_heat_df <- cluster_matrix(fola_heat_df, method ="ward.D2")

# ---- build the basic foc tree ---- #
#dop the non foc tip from the tree
tree_reduced <- drop.tip(tree, fola_set_2)
#build a tree from this data and add in out metadata
fola_tree <- ggtree(tree_reduced, ladderize = T ) %<+% metadata 

# ---- build full foc specific tree ---- #
# now make the tree pretty 
fola_tree_2 <- fola_tree +  
  geom_tiplab(aes(label = fsp), offset = 0.0003) +
  geom_tiplab(aes(label = isolate_code), color = "black", offset = 0.002, linetype = "blank", geom = "text", align = TRUE) +
  geom_tiplab(aes(label = race), offset = 0.0042, linetype = "blank", geom = "text", align = TRUE)+
  geom_tippoint(aes(shape = source), size = 3) +
  geom_rootedge() +
  theme(legend.position = "bottom")

#add extra scale so we can plot fsp with colour
fola_tree_3 <- fola_tree_2 + new_scale_fill()

# add race data
fola_tree_4 <- gheatmap(fola_tree_3, fola_heat_df, offset=0.0065, colnames=T, colnames_angle=90, hjust=1, font.size=3, legend_title="Presence/\nAbsence", color = "grey",  width = 4)  +
  scale_fill_continuous(name = "Presence/\nAbsence",
                        low = "white", high = "darkolivegreen",
                        breaks = c("Absent","Present"),
                        na.value = "grey") +
  guides(fill = guide_colourbar(barwidth = 5, barheight = 1)) +
  theme(legend.position = "bottom",
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 12),
        legend.box = "horizontal", legend.margin = margin())  +
   geom_treescale(x=0, y=.1, width = 0.004) +
  guides(shape = guide_legend(override.aes = list(size = 2))) +
    theme(axis.text.x = element_text(angle = 90,         #Adjust the text orientation on the x axis
                                   vjust = 0.5, 
                                   hjust=1,
                                   size = 8,
                                   colour = "white" )) +
  coord_cartesian(clip = "off") 

# plot the tree
plot(fola_tree_4)

# save the tree
ggsave("HeatmapAndPhylo_LactucaeOnly.png", width = 20, height = 10)

```


### Misc

```{r}
# ---- load session data --- #
session_data <- sessionInfo()
session_data
```

